{"version":3,"file":"static/js/658.4ae5a8db.chunk.js","mappings":"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","sources":["components/game/GameContainer.js","components/game/TextDisplay.js","components/game/ChoiceSelection.js","components/game/SceneRenderer.js","components/ui/CharacterSilhouette.js","components/game/GameScreen.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\r\nimport styled from 'styled-components';\r\n\r\n// Game container component - main interface for the game\r\nconst GameContainer = ({ children, backgroundImage }) => {\r\n  const containerRef = useRef(null);\r\n\r\n  // Update dimensions on resize\r\n  useEffect(() => {\r\n    const updateDimensions = () => {\r\n      // We keep the function for resize handling but don't store dimensions\r\n      // since they're not used elsewhere in the component\r\n    };\r\n\r\n    // Initial dimensions\r\n    updateDimensions();\r\n\r\n    // Add event listener for window resize\r\n    window.addEventListener('resize', updateDimensions);\r\n\r\n    // Clean up\r\n    return () => {\r\n      window.removeEventListener('resize', updateDimensions);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <Container ref={containerRef}>\r\n      <BackgroundLayer backgroundImage={backgroundImage} />\r\n      <ContentLayer>{children}</ContentLayer>\r\n    </Container>\r\n  );\r\n};\r\n\r\n// Styled components\r\nconst Container = styled.div`\r\n  position: relative;\r\n  width: 100%;\r\n  height: 100vh;\r\n  overflow: hidden;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n`;\r\n\r\nconst BackgroundLayer = styled.div`\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  background-image: ${props => props.backgroundImage ? `url(${props.backgroundImage})` : 'none'};\r\n  background-size: cover;\r\n  background-position: center;\r\n  filter: brightness(0.7); /* Darken the background for better text readability */\r\n  transition: background-image 1s ease-in-out;\r\n  \r\n  /* Fallback background if no image is provided */\r\n  background-color: ${props => props.backgroundImage ? 'transparent' : '#121212'};\r\n`;\r\n\r\nconst ContentLayer = styled.div`\r\n  position: relative;\r\n  z-index: 1;\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: flex-end; /* Position content at the bottom */\r\n  align-items: center;\r\n  padding: 2rem;\r\n  box-sizing: border-box;\r\n`;\r\n\r\nexport default GameContainer;","import React, { useState, useEffect, useRef } from 'react';\r\nimport styled from 'styled-components';\r\n\r\n// Text display component with typewriter effect\r\nconst TextDisplay = ({ \r\n  text, \r\n  typingSpeed = 30, \r\n  onComplete = () => {}, \r\n  instantDisplay = false,\r\n  className\r\n}) => {\r\n  const [displayedText, setDisplayedText] = useState('');\r\n  const [isComplete, setIsComplete] = useState(false);\r\n  const textRef = useRef(null);\r\n  const timerRef = useRef(null);\r\n  const charIndexRef = useRef(0);\r\n\r\n  // Reset when text changes\r\n  useEffect(() => {\r\n    charIndexRef.current = 0;\r\n    setDisplayedText('');\r\n    setIsComplete(false);\r\n    \r\n    // Clear any existing timer\r\n    if (timerRef.current) {\r\n      clearInterval(timerRef.current);\r\n    }\r\n\r\n    // If instant display is requested, show the entire text immediately\r\n    if (instantDisplay) {\r\n      setDisplayedText(text);\r\n      setIsComplete(true);\r\n      onComplete();\r\n      return;\r\n    }\r\n\r\n    // Start the typewriter effect\r\n    timerRef.current = setInterval(() => {\r\n      if (charIndexRef.current < text.length) {\r\n        setDisplayedText(prev => prev + text[charIndexRef.current]);\r\n        charIndexRef.current++;\r\n      } else {\r\n        clearInterval(timerRef.current);\r\n        setIsComplete(true);\r\n        onComplete();\r\n      }\r\n    }, typingSpeed);\r\n\r\n    // Clean up on unmount or text change\r\n    return () => {\r\n      if (timerRef.current) {\r\n        clearInterval(timerRef.current);\r\n      }\r\n    };\r\n  }, [text, typingSpeed, onComplete, instantDisplay]);\r\n\r\n  // Handle click to display full text immediately\r\n  const handleClick = () => {\r\n    if (!isComplete) {\r\n      clearInterval(timerRef.current);\r\n      setDisplayedText(text);\r\n      setIsComplete(true);\r\n      onComplete();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <TextContainer \r\n      ref={textRef} \r\n      onClick={handleClick} \r\n      className={className}\r\n      $isComplete={isComplete}\r\n    >\r\n      {displayedText}\r\n      {!isComplete && <Cursor />}\r\n    </TextContainer>\r\n  );\r\n};\r\n\r\n// Styled components\r\nconst TextContainer = styled.div`\r\n  background-color: rgba(0, 0, 0, 0.7);\r\n  color: #f0f0f0;\r\n  padding: 1.5rem;\r\n  border-radius: 8px;\r\n  font-size: 1.2rem;\r\n  line-height: 1.6;\r\n  max-width: 800px;\r\n  width: 100%;\r\n  min-height: 150px;\r\n  margin-bottom: 2rem;\r\n  cursor: ${props => props.$isComplete ? 'default' : 'pointer'};\r\n  position: relative;\r\n  font-family: 'Noto Serif', serif;\r\n  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);\r\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);\r\n  \r\n  /* Add a subtle border */\r\n  border: 1px solid rgba(255, 255, 255, 0.1);\r\n  \r\n  /* Ensure proper text wrapping */\r\n  white-space: pre-wrap;\r\n  word-wrap: break-word;\r\n`;\r\n\r\nconst Cursor = styled.span`\r\n  display: inline-block;\r\n  width: 0.6rem;\r\n  height: 1.2rem;\r\n  background-color: #f0f0f0;\r\n  margin-left: 2px;\r\n  animation: blink 1s infinite;\r\n  vertical-align: middle;\r\n  \r\n  @keyframes blink {\r\n    0%, 100% { opacity: 1; }\r\n    50% { opacity: 0; }\r\n  }\r\n`;\r\n\r\nexport default TextDisplay;","import React, { useState, useEffect } from 'react';\r\nimport styled from 'styled-components';\r\n\r\n// Choice selection component\r\nconst ChoiceSelection = ({ \r\n  choices = [], \r\n  onSelect, \r\n  visible = true,\r\n  className\r\n}) => {\r\n  const [hoveredIndex, setHoveredIndex] = useState(null);\r\n  const [animationComplete, setAnimationComplete] = useState(false);\r\n\r\n  // Reset animation state when choices change\r\n  useEffect(() => {\r\n    setAnimationComplete(false);\r\n    const timer = setTimeout(() => {\r\n      setAnimationComplete(true);\r\n    }, choices.length * 200); // Staggered animation timing\r\n\r\n    return () => clearTimeout(timer);\r\n  }, [choices]);\r\n\r\n  // Handle choice selection\r\n  const handleSelect = (choice, index) => {\r\n    if (onSelect && animationComplete) {\r\n      onSelect(choice, index);\r\n    }\r\n  };\r\n\r\n  if (!visible || choices.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <ChoicesContainer className={className}>\r\n      {choices.map((choice, index) => (\r\n        <ChoiceButton\r\n          key={`choice-${index}`}\r\n          onClick={() => handleSelect(choice, index)}\r\n          onMouseEnter={() => setHoveredIndex(index)}\r\n          onMouseLeave={() => setHoveredIndex(null)}\r\n          isHovered={hoveredIndex === index}\r\n          animationDelay={index * 0.2}\r\n          animationComplete={animationComplete}\r\n          disabled={!animationComplete}\r\n        >\r\n          {choice}\r\n        </ChoiceButton>\r\n      ))}\r\n    </ChoicesContainer>\r\n  );\r\n};\r\n\r\n// Styled components\r\nconst ChoicesContainer = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 1rem;\r\n  width: 100%;\r\n  max-width: 800px;\r\n  margin-bottom: 2rem;\r\n`;\r\n\r\nconst ChoiceButton = styled.button`\r\n  background-color: rgba(0, 0, 0, 0.7);\r\n  color: ${props => props.isHovered ? '#ffffff' : '#d0d0d0'};\r\n  border: 1px solid rgba(255, 255, 255, ${props => props.isHovered ? '0.3' : '0.1'});\r\n  border-radius: 8px;\r\n  padding: 1rem 1.5rem;\r\n  font-size: 1.1rem;\r\n  text-align: left;\r\n  cursor: pointer;\r\n  transition: all 0.2s ease;\r\n  font-family: 'Noto Sans', sans-serif;\r\n  position: relative;\r\n  overflow: hidden;\r\n  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);\r\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\r\n  opacity: ${props => props.animationComplete ? 1 : 0};\r\n  transform: ${props => props.animationComplete ? 'translateY(0)' : 'translateY(20px)'};\r\n  transition: opacity 0.3s ease, transform 0.3s ease, background-color 0.2s ease, color 0.2s ease, border 0.2s ease;\r\n  transition-delay: ${props => props.animationDelay}s;\r\n  \r\n  &:hover, &:focus {\r\n    background-color: rgba(40, 40, 40, 0.9);\r\n    color: #ffffff;\r\n    border-color: rgba(255, 255, 255, 0.5);\r\n    outline: none;\r\n  }\r\n  \r\n  &:active {\r\n    transform: scale(0.98);\r\n  }\r\n  \r\n  /* Add a subtle indicator for the choice */\r\n  &::before {\r\n    content: '•';\r\n    position: absolute;\r\n    left: 0.5rem;\r\n    opacity: ${props => props.isHovered ? 1 : 0};\r\n    transition: opacity 0.2s ease;\r\n  }\r\n  \r\n  /* Disable button styling when animation is not complete */\r\n  &:disabled {\r\n    cursor: default;\r\n    pointer-events: none;\r\n  }\r\n`;\r\n\r\nexport default ChoiceSelection;","import React from 'react';\r\nimport styled from 'styled-components';\r\n\r\n// Simplified SceneRenderer component for text-only mode\r\n// No actual rendering is performed\r\nconst SceneRenderer = ({ \r\n  sceneDescription, \r\n  characters = [], \r\n  mood = 'neutral',\r\n  onRenderComplete = () => {},\r\n  className\r\n}) => {\r\n  // Call onRenderComplete immediately since there's no rendering to wait for\r\n  React.useEffect(() => {\r\n    onRenderComplete();\r\n  }, [onRenderComplete]);\r\n  \r\n  // Return an empty container\r\n  return (\r\n    <EmptyContainer className={className} />\r\n  );\r\n};\r\n\r\n// Styled components\r\nconst EmptyContainer = styled.div`\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  z-index: 0;\r\n`;\r\n\r\nexport default SceneRenderer;","import React from 'react';\r\n\r\n/**\r\n * CharacterSilhouette component - Text-only version\r\n * No visual elements are rendered in text-only mode\r\n */\r\nconst CharacterSilhouette = ({ \r\n  character, \r\n  position = 'center', \r\n  emotion = 'neutral',\r\n  speaking = false,\r\n  entering = false,\r\n  exiting = false,\r\n  size = 'medium'\r\n}) => {\r\n  // In text-only mode, we don't render any visual elements\r\n  return null;\r\n};\r\n\r\nexport default CharacterSilhouette;","import React, { useState, useEffect } from 'react';\r\nimport styled from 'styled-components';\r\nimport { useGame } from '../../contexts/GameContext';\r\nimport GameContainer from './GameContainer';\r\nimport TextDisplay from './TextDisplay';\r\nimport ChoiceSelection from './ChoiceSelection';\r\n// SceneRenderer and CharacterSilhouette are still imported but won't render anything in text-only mode\r\nimport SceneRenderer from './SceneRenderer';\r\nimport CharacterSilhouette from '../ui/CharacterSilhouette';\r\nimport soundEffects from '../../services/audio/soundEffects';\r\n\r\n// Main game screen component\r\nconst GameScreen = () => {\r\n  const game = useGame();\r\n  const [textDisplayComplete, setTextDisplayComplete] = useState(false);\r\n  const [typingSound, setTypingSound] = useState(null);\r\n  \r\n  // Handle text display completion\r\n  const handleTextDisplayComplete = () => {\r\n    setTextDisplayComplete(true);\r\n    \r\n    // Stop typing sound if playing\r\n    if (typingSound) {\r\n      typingSound.stop();\r\n      setTypingSound(null);\r\n    }\r\n  };\r\n  \r\n  // Handle choice selection\r\n  const handleChoiceSelect = (choice, index) => {\r\n    setTextDisplayComplete(false);\r\n    game.selectChoice(index);\r\n  };\r\n  \r\n  // Reset state when scene changes\r\n  useEffect(() => {\r\n    setTextDisplayComplete(false);\r\n    \r\n    // Dummy typing sound object\r\n    if (game.currentScene) {\r\n      setTypingSound({ stop: () => {} });\r\n    }\r\n    \r\n    // Clean up\r\n    return () => {\r\n      if (typingSound) {\r\n        typingSound.stop();\r\n      }\r\n    };\r\n  }, [game.currentScene]);\r\n  \r\n  // If no current scene, show loading\r\n  if (!game.currentScene) {\r\n    return (\r\n      <GameContainer>\r\n        <LoadingContainer>\r\n          <LoadingSpinner />\r\n          <LoadingText>이야기 불러오는 중...</LoadingText>\r\n        </LoadingContainer>\r\n      </GameContainer>\r\n    );\r\n  }\r\n  \r\n  return (\r\n    <GameContainer>\r\n      {/* Scene renderer is kept for compatibility but doesn't render anything in text-only mode */}\r\n      <SceneRenderer \r\n        sceneDescription={game.currentScene.content}\r\n        characters={game.characters}\r\n        mood={game.currentScene.mood}\r\n      />\r\n      \r\n      {/* Character silhouettes are kept for compatibility but don't render anything in text-only mode */}\r\n      {game.characters.map(character => (\r\n        <CharacterSilhouette\r\n          key={character.id}\r\n          character={character}\r\n          position={character.position}\r\n          emotion={character.emotion || 'neutral'}\r\n          size={character.size || 'medium'}\r\n        />\r\n      ))}\r\n      \r\n      {/* Game UI */}\r\n      <GameUI>\r\n        {/* Text display */}\r\n        <TextDisplay\r\n          text={game.currentScene.content}\r\n          typingSpeed={game.settings.textSpeed}\r\n          onComplete={handleTextDisplayComplete}\r\n          instantDisplay={game.isLoading}\r\n        />\r\n        \r\n        {/* Choice selection */}\r\n        <ChoiceSelection\r\n          choices={game.currentScene.choices}\r\n          onSelect={handleChoiceSelect}\r\n          visible={textDisplayComplete && !game.isLoading}\r\n        />\r\n      </GameUI>\r\n      \r\n      {/* Loading overlay */}\r\n      {game.isLoading && (\r\n        <LoadingOverlay>\r\n          <LoadingSpinner />\r\n        </LoadingOverlay>\r\n      )}\r\n      \r\n      {/* Game controls */}\r\n      <GameControls>\r\n        <ControlButton onClick={() => game.setCurrentScreen('settings')}>\r\n          설정\r\n        </ControlButton>\r\n        <ControlButton onClick={() => game.setCurrentScreen('title')}>\r\n          메인 메뉴\r\n        </ControlButton>\r\n      </GameControls>\r\n    </GameContainer>\r\n  );\r\n};\r\n\r\n// Styled components\r\nconst GameUI = styled.div`\r\n  position: absolute;\r\n  bottom: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  padding: 1rem;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  z-index: 10;\r\n`;\r\n\r\nconst LoadingContainer = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  height: 100%;\r\n  color: #ffffff;\r\n`;\r\n\r\nconst LoadingText = styled.div`\r\n  margin-top: 1rem;\r\n  font-size: 1.2rem;\r\n  font-family: 'Noto Sans', sans-serif;\r\n`;\r\n\r\nconst LoadingSpinner = styled.div`\r\n  width: 50px;\r\n  height: 50px;\r\n  border: 5px solid rgba(255, 255, 255, 0.3);\r\n  border-radius: 50%;\r\n  border-top-color: #ffffff;\r\n  animation: spin 1s ease-in-out infinite;\r\n  \r\n  @keyframes spin {\r\n    to { transform: rotate(360deg); }\r\n  }\r\n`;\r\n\r\nconst LoadingOverlay = styled.div`\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  background-color: rgba(0, 0, 0, 0.7);\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  z-index: 100;\r\n`;\r\n\r\nconst GameControls = styled.div`\r\n  position: absolute;\r\n  top: 1rem;\r\n  right: 1rem;\r\n  display: flex;\r\n  gap: 0.5rem;\r\n  z-index: 20;\r\n`;\r\n\r\nconst ControlButton = styled.button`\r\n  background-color: rgba(0, 0, 0, 0.7);\r\n  color: #d0d0d0;\r\n  border: 1px solid rgba(255, 255, 255, 0.2);\r\n  border-radius: 4px;\r\n  padding: 0.5rem 1rem;\r\n  font-size: 0.9rem;\r\n  cursor: pointer;\r\n  transition: all 0.2s ease;\r\n  \r\n  &:hover {\r\n    background-color: rgba(40, 40, 40, 0.9);\r\n    color: #ffffff;\r\n    border-color: rgba(255, 255, 255, 0.5);\r\n  }\r\n`;\r\n\r\nexport default GameScreen;"],"names":["Container","styled","div","BackgroundLayer","props","backgroundImage","ContentLayer","_ref","children","containerRef","useRef","useEffect","updateDimensions","window","addEventListener","removeEventListener","_jsxs","ref","_jsx","TextContainer","$isComplete","Cursor","span","text","typingSpeed","onComplete","instantDisplay","className","displayedText","setDisplayedText","useState","isComplete","setIsComplete","textRef","timerRef","charIndexRef","current","clearInterval","setInterval","length","prev","onClick","handleClick","ChoicesContainer","ChoiceButton","button","isHovered","animationComplete","animationDelay","choices","onSelect","visible","hoveredIndex","setHoveredIndex","setAnimationComplete","timer","setTimeout","clearTimeout","map","choice","index","handleSelect","onMouseEnter","onMouseLeave","disabled","EmptyContainer","sceneDescription","characters","mood","onRenderComplete","React","character","position","emotion","speaking","entering","exiting","size","GameUI","LoadingContainer","LoadingText","LoadingSpinner","LoadingOverlay","GameControls","ControlButton","GameScreen","game","useGame","textDisplayComplete","setTextDisplayComplete","typingSound","setTypingSound","currentScene","stop","GameContainer","SceneRenderer","content","CharacterSilhouette","id","TextDisplay","settings","textSpeed","handleTextDisplayComplete","isLoading","ChoiceSelection","handleChoiceSelect","selectChoice","setCurrentScreen"],"sourceRoot":""}