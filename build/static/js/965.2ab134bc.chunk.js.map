{"version":3,"file":"static/js/965.2ab134bc.chunk.js","mappings":"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","sources":["components/game/GameContainer.js","components/game/TextDisplay.js","components/game/ChoiceSelection.js","services/canvas/canvasRenderer.js","components/game/SceneRenderer.js","components/ui/CharacterSilhouette.js","components/game/GameScreen.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\r\nimport styled from 'styled-components';\r\n\r\n// Game container component - main interface for the game\r\nconst GameContainer = ({ children, backgroundImage }) => {\r\n  const containerRef = useRef(null);\r\n\r\n  // Update dimensions on resize\r\n  useEffect(() => {\r\n    const updateDimensions = () => {\r\n      // We keep the function for resize handling but don't store dimensions\r\n      // since they're not used elsewhere in the component\r\n    };\r\n\r\n    // Initial dimensions\r\n    updateDimensions();\r\n\r\n    // Add event listener for window resize\r\n    window.addEventListener('resize', updateDimensions);\r\n\r\n    // Clean up\r\n    return () => {\r\n      window.removeEventListener('resize', updateDimensions);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <Container ref={containerRef}>\r\n      <BackgroundLayer backgroundImage={backgroundImage} />\r\n      <ContentLayer>{children}</ContentLayer>\r\n    </Container>\r\n  );\r\n};\r\n\r\n// Styled components\r\nconst Container = styled.div`\r\n  position: relative;\r\n  width: 100%;\r\n  height: 100vh;\r\n  overflow: hidden;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n`;\r\n\r\nconst BackgroundLayer = styled.div`\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  background-image: ${props => props.backgroundImage ? `url(${props.backgroundImage})` : 'none'};\r\n  background-size: cover;\r\n  background-position: center;\r\n  filter: brightness(0.7); /* Darken the background for better text readability */\r\n  transition: background-image 1s ease-in-out;\r\n  \r\n  /* Fallback background if no image is provided */\r\n  background-color: ${props => props.backgroundImage ? 'transparent' : '#121212'};\r\n`;\r\n\r\nconst ContentLayer = styled.div`\r\n  position: relative;\r\n  z-index: 1;\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: flex-end; /* Position content at the bottom */\r\n  align-items: center;\r\n  padding: 2rem;\r\n  box-sizing: border-box;\r\n`;\r\n\r\nexport default GameContainer;","import React, { useState, useEffect, useRef } from 'react';\r\nimport styled from 'styled-components';\r\n\r\n// Text display component with typewriter effect\r\nconst TextDisplay = ({ \r\n  text, \r\n  typingSpeed = 30, \r\n  onComplete = () => {}, \r\n  instantDisplay = false,\r\n  className\r\n}) => {\r\n  const [displayedText, setDisplayedText] = useState('');\r\n  const [isComplete, setIsComplete] = useState(false);\r\n  const textRef = useRef(null);\r\n  const timerRef = useRef(null);\r\n  const charIndexRef = useRef(0);\r\n\r\n  // Reset when text changes\r\n  useEffect(() => {\r\n    charIndexRef.current = 0;\r\n    setDisplayedText('');\r\n    setIsComplete(false);\r\n    \r\n    // Clear any existing timer\r\n    if (timerRef.current) {\r\n      clearInterval(timerRef.current);\r\n    }\r\n\r\n    // If instant display is requested, show the entire text immediately\r\n    if (instantDisplay) {\r\n      setDisplayedText(text);\r\n      setIsComplete(true);\r\n      onComplete();\r\n      return;\r\n    }\r\n\r\n    // Start the typewriter effect\r\n    timerRef.current = setInterval(() => {\r\n      if (charIndexRef.current < text.length) {\r\n        setDisplayedText(prev => prev + text[charIndexRef.current]);\r\n        charIndexRef.current++;\r\n      } else {\r\n        clearInterval(timerRef.current);\r\n        setIsComplete(true);\r\n        onComplete();\r\n      }\r\n    }, typingSpeed);\r\n\r\n    // Clean up on unmount or text change\r\n    return () => {\r\n      if (timerRef.current) {\r\n        clearInterval(timerRef.current);\r\n      }\r\n    };\r\n  }, [text, typingSpeed, onComplete, instantDisplay]);\r\n\r\n  // Handle click to display full text immediately\r\n  const handleClick = () => {\r\n    if (!isComplete) {\r\n      clearInterval(timerRef.current);\r\n      setDisplayedText(text);\r\n      setIsComplete(true);\r\n      onComplete();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <TextContainer \r\n      ref={textRef} \r\n      onClick={handleClick} \r\n      className={className}\r\n      isComplete={isComplete}\r\n    >\r\n      {displayedText}\r\n      {!isComplete && <Cursor />}\r\n    </TextContainer>\r\n  );\r\n};\r\n\r\n// Styled components\r\nconst TextContainer = styled.div`\r\n  background-color: rgba(0, 0, 0, 0.7);\r\n  color: #f0f0f0;\r\n  padding: 1.5rem;\r\n  border-radius: 8px;\r\n  font-size: 1.2rem;\r\n  line-height: 1.6;\r\n  max-width: 800px;\r\n  width: 100%;\r\n  min-height: 150px;\r\n  margin-bottom: 2rem;\r\n  cursor: ${props => props.isComplete ? 'default' : 'pointer'};\r\n  position: relative;\r\n  font-family: 'Noto Serif', serif;\r\n  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);\r\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);\r\n  \r\n  /* Add a subtle border */\r\n  border: 1px solid rgba(255, 255, 255, 0.1);\r\n  \r\n  /* Ensure proper text wrapping */\r\n  white-space: pre-wrap;\r\n  word-wrap: break-word;\r\n`;\r\n\r\nconst Cursor = styled.span`\r\n  display: inline-block;\r\n  width: 0.6rem;\r\n  height: 1.2rem;\r\n  background-color: #f0f0f0;\r\n  margin-left: 2px;\r\n  animation: blink 1s infinite;\r\n  vertical-align: middle;\r\n  \r\n  @keyframes blink {\r\n    0%, 100% { opacity: 1; }\r\n    50% { opacity: 0; }\r\n  }\r\n`;\r\n\r\nexport default TextDisplay;","import React, { useState, useEffect } from 'react';\r\nimport styled from 'styled-components';\r\n\r\n// Choice selection component\r\nconst ChoiceSelection = ({ \r\n  choices = [], \r\n  onSelect, \r\n  visible = true,\r\n  className\r\n}) => {\r\n  const [hoveredIndex, setHoveredIndex] = useState(null);\r\n  const [animationComplete, setAnimationComplete] = useState(false);\r\n\r\n  // Reset animation state when choices change\r\n  useEffect(() => {\r\n    setAnimationComplete(false);\r\n    const timer = setTimeout(() => {\r\n      setAnimationComplete(true);\r\n    }, choices.length * 200); // Staggered animation timing\r\n\r\n    return () => clearTimeout(timer);\r\n  }, [choices]);\r\n\r\n  // Handle choice selection\r\n  const handleSelect = (choice, index) => {\r\n    if (onSelect && animationComplete) {\r\n      onSelect(choice, index);\r\n    }\r\n  };\r\n\r\n  if (!visible || choices.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <ChoicesContainer className={className}>\r\n      {choices.map((choice, index) => (\r\n        <ChoiceButton\r\n          key={`choice-${index}`}\r\n          onClick={() => handleSelect(choice, index)}\r\n          onMouseEnter={() => setHoveredIndex(index)}\r\n          onMouseLeave={() => setHoveredIndex(null)}\r\n          isHovered={hoveredIndex === index}\r\n          animationDelay={index * 0.2}\r\n          animationComplete={animationComplete}\r\n          disabled={!animationComplete}\r\n        >\r\n          {choice}\r\n        </ChoiceButton>\r\n      ))}\r\n    </ChoicesContainer>\r\n  );\r\n};\r\n\r\n// Styled components\r\nconst ChoicesContainer = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 1rem;\r\n  width: 100%;\r\n  max-width: 800px;\r\n  margin-bottom: 2rem;\r\n`;\r\n\r\nconst ChoiceButton = styled.button`\r\n  background-color: rgba(0, 0, 0, 0.7);\r\n  color: ${props => props.isHovered ? '#ffffff' : '#d0d0d0'};\r\n  border: 1px solid rgba(255, 255, 255, ${props => props.isHovered ? '0.3' : '0.1'});\r\n  border-radius: 8px;\r\n  padding: 1rem 1.5rem;\r\n  font-size: 1.1rem;\r\n  text-align: left;\r\n  cursor: pointer;\r\n  transition: all 0.2s ease;\r\n  font-family: 'Noto Sans', sans-serif;\r\n  position: relative;\r\n  overflow: hidden;\r\n  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);\r\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\r\n  opacity: ${props => props.animationComplete ? 1 : 0};\r\n  transform: ${props => props.animationComplete ? 'translateY(0)' : 'translateY(20px)'};\r\n  transition: opacity 0.3s ease, transform 0.3s ease, background-color 0.2s ease, color 0.2s ease, border 0.2s ease;\r\n  transition-delay: ${props => props.animationDelay}s;\r\n  \r\n  &:hover, &:focus {\r\n    background-color: rgba(40, 40, 40, 0.9);\r\n    color: #ffffff;\r\n    border-color: rgba(255, 255, 255, 0.5);\r\n    outline: none;\r\n  }\r\n  \r\n  &:active {\r\n    transform: scale(0.98);\r\n  }\r\n  \r\n  /* Add a subtle indicator for the choice */\r\n  &::before {\r\n    content: '•';\r\n    position: absolute;\r\n    left: 0.5rem;\r\n    opacity: ${props => props.isHovered ? 1 : 0};\r\n    transition: opacity 0.2s ease;\r\n  }\r\n  \r\n  /* Disable button styling when animation is not complete */\r\n  &:disabled {\r\n    cursor: default;\r\n    pointer-events: none;\r\n  }\r\n`;\r\n\r\nexport default ChoiceSelection;","// Canvas rendering service for dynamic graphics\r\nimport { useEffect } from 'react';\r\n\r\n// Canvas rendering class\r\nclass CanvasRenderer {\r\n  constructor() {\r\n    this.canvas = null;\r\n    this.ctx = null;\r\n    this.width = 0;\r\n    this.height = 0;\r\n    this.renderQueue = [];\r\n    this.animationFrameId = null;\r\n    this.isRendering = false;\r\n  }\r\n\r\n  // Initialize the canvas\r\n  initialize(canvas, width, height) {\r\n    this.canvas = canvas;\r\n    this.ctx = canvas.getContext('2d');\r\n    this.width = width || canvas.width;\r\n    this.height = height || canvas.height;\r\n    \r\n    // Set canvas dimensions\r\n    this.canvas.width = this.width;\r\n    this.canvas.height = this.height;\r\n    \r\n    console.log(`Canvas initialized with dimensions ${this.width}x${this.height}`);\r\n    return this;\r\n  }\r\n\r\n  // Clear the canvas\r\n  clear() {\r\n    if (!this.ctx) return;\r\n    this.ctx.clearRect(0, 0, this.width, this.height);\r\n  }\r\n\r\n  // Start the render loop\r\n  startRendering() {\r\n    if (this.isRendering) return;\r\n    this.isRendering = true;\r\n    this.render();\r\n  }\r\n\r\n  // Stop the render loop\r\n  stopRendering() {\r\n    this.isRendering = false;\r\n    if (this.animationFrameId) {\r\n      cancelAnimationFrame(this.animationFrameId);\r\n      this.animationFrameId = null;\r\n    }\r\n  }\r\n\r\n  // Main render loop\r\n  render() {\r\n    if (!this.isRendering) return;\r\n    \r\n    // Process render queue\r\n    while (this.renderQueue.length > 0) {\r\n      const renderItem = this.renderQueue.shift();\r\n      renderItem.render(this.ctx, this.width, this.height);\r\n    }\r\n    \r\n    // Continue render loop\r\n    this.animationFrameId = requestAnimationFrame(() => this.render());\r\n  }\r\n\r\n  // Add an item to the render queue\r\n  addToRenderQueue(renderItem) {\r\n    this.renderQueue.push(renderItem);\r\n    if (!this.isRendering) {\r\n      this.startRendering();\r\n    }\r\n  }\r\n\r\n  // Draw a background scene based on description\r\n  drawBackgroundScene(description, options = {}) {\r\n    const {\r\n      palette = ['#1a1a2e', '#16213e', '#0f3460', '#e94560'],\r\n      complexity = 0.5,\r\n      mood = 'neutral' // 'dark', 'light', 'mysterious', 'tense', etc.\r\n    } = options;\r\n    \r\n    // Create a render item for the background\r\n    const backgroundRender = {\r\n      render: (ctx, width, height) => {\r\n        // Clear canvas\r\n        ctx.clearRect(0, 0, width, height);\r\n        \r\n        // Parse description for key elements\r\n        const isNight = description.toLowerCase().includes('night') || \r\n                        description.toLowerCase().includes('dark');\r\n        const isRaining = description.toLowerCase().includes('rain');\r\n        const isFoggy = description.toLowerCase().includes('fog') || \r\n                        description.toLowerCase().includes('mist');\r\n        const isForest = description.toLowerCase().includes('forest') || \r\n                         description.toLowerCase().includes('trees');\r\n        const isIndoor = description.toLowerCase().includes('room') || \r\n                         description.toLowerCase().includes('inside') ||\r\n                         description.toLowerCase().includes('interior');\r\n        \r\n        // Set base colors based on mood and time\r\n        let skyColor, groundColor, middleColor;\r\n        \r\n        if (isNight) {\r\n          skyColor = '#0a0a1a';\r\n          groundColor = '#0f0f1f';\r\n          middleColor = '#141428';\r\n        } else {\r\n          skyColor = '#4a6ea5';\r\n          groundColor = '#2c4c2c';\r\n          middleColor = '#3a5a3a';\r\n        }\r\n        \r\n        // Override with palette if provided\r\n        if (palette.length >= 3) {\r\n          [skyColor, groundColor, middleColor] = palette;\r\n        }\r\n        \r\n        // Adjust based on mood\r\n        if (mood === 'dark' || mood === 'tense') {\r\n          skyColor = this.darkenColor(skyColor, 0.3);\r\n          groundColor = this.darkenColor(groundColor, 0.3);\r\n          middleColor = this.darkenColor(middleColor, 0.3);\r\n        } else if (mood === 'light') {\r\n          skyColor = this.lightenColor(skyColor, 0.3);\r\n          groundColor = this.lightenColor(groundColor, 0.3);\r\n          middleColor = this.lightenColor(middleColor, 0.3);\r\n        } else if (mood === 'mysterious') {\r\n          // Add a purple tint\r\n          skyColor = this.blendColors(skyColor, '#2a0a4a', 0.3);\r\n          groundColor = this.blendColors(groundColor, '#1a0a2a', 0.3);\r\n          middleColor = this.blendColors(middleColor, '#2a0a3a', 0.3);\r\n        }\r\n        \r\n        // Draw sky gradient\r\n        const skyGradient = ctx.createLinearGradient(0, 0, 0, height * 0.6);\r\n        skyGradient.addColorStop(0, skyColor);\r\n        skyGradient.addColorStop(1, this.blendColors(skyColor, middleColor, 0.5));\r\n        \r\n        ctx.fillStyle = skyGradient;\r\n        ctx.fillRect(0, 0, width, height * 0.6);\r\n        \r\n        // Draw ground\r\n        const groundGradient = ctx.createLinearGradient(0, height * 0.6, 0, height);\r\n        groundGradient.addColorStop(0, middleColor);\r\n        groundGradient.addColorStop(1, groundColor);\r\n        \r\n        ctx.fillStyle = groundGradient;\r\n        ctx.fillRect(0, height * 0.6, width, height * 0.4);\r\n        \r\n        // Draw environment elements based on description\r\n        if (isForest && !isIndoor) {\r\n          // Draw trees\r\n          const treeCount = Math.floor(10 + complexity * 20);\r\n          for (let i = 0; i < treeCount; i++) {\r\n            const x = Math.random() * width;\r\n            const y = height * 0.6 + Math.random() * (height * 0.3);\r\n            const treeHeight = 50 + Math.random() * 100;\r\n            const treeWidth = 10 + Math.random() * 20;\r\n            \r\n            // Tree trunk\r\n            ctx.fillStyle = '#3a2a1a';\r\n            ctx.fillRect(x - treeWidth/2, y - treeHeight, treeWidth, treeHeight);\r\n            \r\n            // Tree foliage\r\n            ctx.fillStyle = isNight ? '#1a2a1a' : '#2a4a2a';\r\n            ctx.beginPath();\r\n            ctx.arc(x, y - treeHeight, treeWidth * 3, 0, Math.PI * 2);\r\n            ctx.fill();\r\n          }\r\n        } else if (isIndoor) {\r\n          // Draw room elements\r\n          \r\n          // Walls\r\n          ctx.fillStyle = this.lightenColor(middleColor, 0.2);\r\n          ctx.fillRect(0, 0, width, height);\r\n          \r\n          // Floor\r\n          ctx.fillStyle = this.darkenColor(groundColor, 0.1);\r\n          ctx.fillRect(0, height * 0.7, width, height * 0.3);\r\n          \r\n          // Window (if night or raining)\r\n          if (isNight || isRaining) {\r\n            const windowWidth = width * 0.3;\r\n            const windowHeight = height * 0.4;\r\n            const windowX = width * 0.6;\r\n            const windowY = height * 0.2;\r\n            \r\n            // Window frame\r\n            ctx.fillStyle = '#2a2a2a';\r\n            ctx.fillRect(windowX, windowY, windowWidth, windowHeight);\r\n            \r\n            // Window glass\r\n            ctx.fillStyle = isNight ? '#0a0a2a' : '#4a6ea5';\r\n            ctx.fillRect(windowX + 10, windowY + 10, windowWidth - 20, windowHeight - 20);\r\n            \r\n            // Rain effect on window\r\n            if (isRaining) {\r\n              ctx.strokeStyle = 'rgba(200, 200, 255, 0.5)';\r\n              ctx.lineWidth = 1;\r\n              \r\n              for (let i = 0; i < 20; i++) {\r\n                const rainX = windowX + 10 + Math.random() * (windowWidth - 20);\r\n                const rainY = windowY + 10 + Math.random() * (windowHeight - 20);\r\n                const rainLength = 5 + Math.random() * 15;\r\n                \r\n                ctx.beginPath();\r\n                ctx.moveTo(rainX, rainY);\r\n                ctx.lineTo(rainX + 2, rainY + rainLength);\r\n                ctx.stroke();\r\n              }\r\n            }\r\n          }\r\n        }\r\n        \r\n        // Add atmospheric effects\r\n        if (isRaining && !isIndoor) {\r\n          // Rain effect\r\n          ctx.strokeStyle = 'rgba(200, 200, 255, 0.5)';\r\n          ctx.lineWidth = 1;\r\n          \r\n          for (let i = 0; i < 100; i++) {\r\n            const rainX = Math.random() * width;\r\n            const rainY = Math.random() * height;\r\n            const rainLength = 10 + Math.random() * 20;\r\n            \r\n            ctx.beginPath();\r\n            ctx.moveTo(rainX, rainY);\r\n            ctx.lineTo(rainX + 4, rainY + rainLength);\r\n            ctx.stroke();\r\n          }\r\n        }\r\n        \r\n        if (isFoggy) {\r\n          // Fog effect\r\n          ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';\r\n          \r\n          for (let i = 0; i < 5; i++) {\r\n            const fogY = Math.random() * height;\r\n            const fogHeight = 50 + Math.random() * 100;\r\n            \r\n            ctx.beginPath();\r\n            ctx.rect(0, fogY, width, fogHeight);\r\n            ctx.fill();\r\n          }\r\n        }\r\n        \r\n        // Add complexity based on the complexity parameter\r\n        const detailCount = Math.floor(complexity * 50);\r\n        for (let i = 0; i < detailCount; i++) {\r\n          const x = Math.random() * width;\r\n          const y = Math.random() * height;\r\n          const size = 1 + Math.random() * 3;\r\n          \r\n          ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.1})`;\r\n          ctx.beginPath();\r\n          ctx.arc(x, y, size, 0, Math.PI * 2);\r\n          ctx.fill();\r\n        }\r\n      }\r\n    };\r\n    \r\n    // Add to render queue\r\n    this.addToRenderQueue(backgroundRender);\r\n  }\r\n\r\n  // Draw a silhouette based on description\r\n  drawSilhouette(description, position, options = {}) {\r\n    const {\r\n      size = 100,\r\n      opacity = 0.8,\r\n      color = '#000000'\r\n    } = options;\r\n    \r\n    // Create a render item for the silhouette\r\n    const silhouetteRender = {\r\n      render: (ctx, width, height) => {\r\n        // Parse position\r\n        let x, y;\r\n        if (position === 'left') {\r\n          x = width * 0.25;\r\n          y = height * 0.8;\r\n        } else if (position === 'right') {\r\n          x = width * 0.75;\r\n          y = height * 0.8;\r\n        } else { // center\r\n          x = width * 0.5;\r\n          y = height * 0.8;\r\n        }\r\n        \r\n        // Parse description for character traits\r\n        const isTall = description.toLowerCase().includes('tall');\r\n        const isShort = description.toLowerCase().includes('short');\r\n        const isSlender = description.toLowerCase().includes('slender') || \r\n                          description.toLowerCase().includes('thin');\r\n        const isLarge = description.toLowerCase().includes('large') || \r\n                        description.toLowerCase().includes('big');\r\n        \r\n        // Adjust size based on description\r\n        let actualSize = size;\r\n        if (isTall) actualSize *= 1.2;\r\n        if (isShort) actualSize *= 0.8;\r\n        if (isSlender) actualSize *= 0.9;\r\n        if (isLarge) actualSize *= 1.3;\r\n        \r\n        // Draw silhouette\r\n        ctx.fillStyle = `rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, ${opacity})`;\r\n        \r\n        // Head\r\n        const headRadius = actualSize * 0.2;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y - actualSize * 0.8, headRadius, 0, Math.PI * 2);\r\n        ctx.fill();\r\n        \r\n        // Body\r\n        ctx.beginPath();\r\n        ctx.moveTo(x - actualSize * 0.3, y - actualSize * 0.6);\r\n        ctx.lineTo(x - actualSize * 0.25, y);\r\n        ctx.lineTo(x + actualSize * 0.25, y);\r\n        ctx.lineTo(x + actualSize * 0.3, y - actualSize * 0.6);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        \r\n        // Arms\r\n        ctx.beginPath();\r\n        ctx.moveTo(x - actualSize * 0.3, y - actualSize * 0.55);\r\n        ctx.lineTo(x - actualSize * 0.5, y - actualSize * 0.3);\r\n        ctx.lineTo(x - actualSize * 0.45, y - actualSize * 0.25);\r\n        ctx.lineTo(x - actualSize * 0.25, y - actualSize * 0.5);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        \r\n        ctx.beginPath();\r\n        ctx.moveTo(x + actualSize * 0.3, y - actualSize * 0.55);\r\n        ctx.lineTo(x + actualSize * 0.5, y - actualSize * 0.3);\r\n        ctx.lineTo(x + actualSize * 0.45, y - actualSize * 0.25);\r\n        ctx.lineTo(x + actualSize * 0.25, y - actualSize * 0.5);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n      }\r\n    };\r\n    \r\n    // Add to render queue\r\n    this.addToRenderQueue(silhouetteRender);\r\n  }\r\n\r\n  // Draw a visual effect based on description\r\n  drawEffect(description, options = {}) {\r\n    const {\r\n      intensity = 0.5,\r\n      duration = 2000,\r\n      color = '#ffffff'\r\n    } = options;\r\n    \r\n    // Create a render item for the effect\r\n    const effectRender = {\r\n      startTime: Date.now(),\r\n      duration: duration,\r\n      render: (ctx, width, height) => {\r\n        // Calculate progress (0 to 1)\r\n        const elapsed = Date.now() - effectRender.startTime;\r\n        const progress = Math.min(elapsed / effectRender.duration, 1);\r\n        \r\n        // Remove from render queue if complete\r\n        if (progress >= 1) {\r\n          const index = this.renderQueue.indexOf(effectRender);\r\n          if (index !== -1) {\r\n            this.renderQueue.splice(index, 1);\r\n          }\r\n          return;\r\n        }\r\n        \r\n        // Parse description for effect type\r\n        const isFlash = description.toLowerCase().includes('flash');\r\n        const isFade = description.toLowerCase().includes('fade');\r\n        const isShake = description.toLowerCase().includes('shake');\r\n        const isReveal = description.toLowerCase().includes('reveal');\r\n        \r\n        // Apply effect based on type\r\n        if (isFlash) {\r\n          // Flash effect\r\n          const alpha = intensity * Math.sin(progress * Math.PI);\r\n          ctx.fillStyle = `rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, ${alpha})`;\r\n          ctx.fillRect(0, 0, width, height);\r\n        } else if (isFade) {\r\n          // Fade effect\r\n          const alpha = intensity * (isFade.includes('in') ? progress : 1 - progress);\r\n          ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;\r\n          ctx.fillRect(0, 0, width, height);\r\n        } else if (isShake) {\r\n          // Shake effect\r\n          const amplitude = intensity * 10 * (1 - progress);\r\n          const offsetX = Math.random() * amplitude * 2 - amplitude;\r\n          const offsetY = Math.random() * amplitude * 2 - amplitude;\r\n          \r\n          ctx.save();\r\n          ctx.translate(offsetX, offsetY);\r\n          // Note: This doesn't actually move the canvas, just saves the state\r\n          // In a real implementation, you'd need to redraw the scene with the offset\r\n          ctx.restore();\r\n        } else if (isReveal) {\r\n          // Reveal effect\r\n          const revealProgress = progress;\r\n          ctx.fillStyle = 'rgba(0, 0, 0, 1)';\r\n          \r\n          if (description.toLowerCase().includes('left')) {\r\n            ctx.fillRect(width * revealProgress, 0, width * (1 - revealProgress), height);\r\n          } else if (description.toLowerCase().includes('right')) {\r\n            ctx.fillRect(0, 0, width * (1 - revealProgress), height);\r\n          } else if (description.toLowerCase().includes('top')) {\r\n            ctx.fillRect(0, height * revealProgress, width, height * (1 - revealProgress));\r\n          } else if (description.toLowerCase().includes('bottom')) {\r\n            ctx.fillRect(0, 0, width, height * (1 - revealProgress));\r\n          } else {\r\n            // Circular reveal\r\n            const radius = Math.sqrt(width * width + height * height) * revealProgress;\r\n            ctx.beginPath();\r\n            ctx.arc(width / 2, height / 2, radius, 0, Math.PI * 2);\r\n            ctx.clip();\r\n            // In a real implementation, you'd redraw the scene here\r\n          }\r\n        }\r\n      }\r\n    };\r\n    \r\n    // Add to render queue\r\n    this.addToRenderQueue(effectRender);\r\n    \r\n    // Return a promise that resolves when the effect is complete\r\n    return new Promise(resolve => {\r\n      setTimeout(resolve, duration);\r\n    });\r\n  }\r\n\r\n  // Utility: Darken a color\r\n  darkenColor(color, amount) {\r\n    const r = parseInt(color.slice(1, 3), 16);\r\n    const g = parseInt(color.slice(3, 5), 16);\r\n    const b = parseInt(color.slice(5, 7), 16);\r\n    \r\n    const newR = Math.max(0, Math.floor(r * (1 - amount)));\r\n    const newG = Math.max(0, Math.floor(g * (1 - amount)));\r\n    const newB = Math.max(0, Math.floor(b * (1 - amount)));\r\n    \r\n    return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;\r\n  }\r\n\r\n  // Utility: Lighten a color\r\n  lightenColor(color, amount) {\r\n    const r = parseInt(color.slice(1, 3), 16);\r\n    const g = parseInt(color.slice(3, 5), 16);\r\n    const b = parseInt(color.slice(5, 7), 16);\r\n    \r\n    const newR = Math.min(255, Math.floor(r + (255 - r) * amount));\r\n    const newG = Math.min(255, Math.floor(g + (255 - g) * amount));\r\n    const newB = Math.min(255, Math.floor(b + (255 - b) * amount));\r\n    \r\n    return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;\r\n  }\r\n\r\n  // Utility: Blend two colors\r\n  blendColors(color1, color2, ratio) {\r\n    const r1 = parseInt(color1.slice(1, 3), 16);\r\n    const g1 = parseInt(color1.slice(3, 5), 16);\r\n    const b1 = parseInt(color1.slice(5, 7), 16);\r\n    \r\n    const r2 = parseInt(color2.slice(1, 3), 16);\r\n    const g2 = parseInt(color2.slice(3, 5), 16);\r\n    const b2 = parseInt(color2.slice(5, 7), 16);\r\n    \r\n    const newR = Math.floor(r1 * (1 - ratio) + r2 * ratio);\r\n    const newG = Math.floor(g1 * (1 - ratio) + g2 * ratio);\r\n    const newB = Math.floor(b1 * (1 - ratio) + b2 * ratio);\r\n    \r\n    return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;\r\n  }\r\n}\r\n\r\n// Create and export a singleton instance\r\nconst canvasRenderer = new CanvasRenderer();\r\n\r\n// React hook for using the canvas renderer\r\nexport const useCanvasRenderer = (canvasRef, width, height) => {\r\n  useEffect(() => {\r\n    if (canvasRef.current) {\r\n      canvasRenderer.initialize(canvasRef.current, width, height);\r\n      canvasRenderer.startRendering();\r\n      \r\n      return () => {\r\n        canvasRenderer.stopRendering();\r\n      };\r\n    }\r\n  }, [canvasRef, width, height]);\r\n  \r\n  return canvasRenderer;\r\n};\r\n\r\nexport default canvasRenderer;","import React, { useRef, useEffect, useState } from 'react';\r\nimport styled from 'styled-components';\r\nimport { useCanvasRenderer } from '../../services/canvas/canvasRenderer';\r\nimport llmService from '../../services/llm';\r\n\r\n// Scene renderer component that integrates canvas with LLM\r\nconst SceneRenderer = ({ \r\n  sceneDescription, \r\n  characters = [], \r\n  mood = 'neutral',\r\n  onRenderComplete = () => {},\r\n  className\r\n}) => {\r\n  const canvasRef = useRef(null);\r\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\r\n  const [isRendering, setIsRendering] = useState(false);\r\n  const renderer = useCanvasRenderer(canvasRef, dimensions.width, dimensions.height);\r\n  \r\n  // Update dimensions on resize\r\n  useEffect(() => {\r\n    const updateDimensions = () => {\r\n      if (canvasRef.current) {\r\n        const { clientWidth, clientHeight } = canvasRef.current.parentElement;\r\n        setDimensions({\r\n          width: clientWidth,\r\n          height: clientHeight\r\n        });\r\n      }\r\n    };\r\n    \r\n    // Initial dimensions\r\n    updateDimensions();\r\n    \r\n    // Add event listener for window resize\r\n    window.addEventListener('resize', updateDimensions);\r\n    \r\n    // Clean up\r\n    return () => {\r\n      window.removeEventListener('resize', updateDimensions);\r\n    };\r\n  }, []);\r\n  \r\n  // Render scene when description changes\r\n  useEffect(() => {\r\n    if (!sceneDescription || !renderer || dimensions.width === 0) return;\r\n    \r\n    const renderScene = async () => {\r\n      setIsRendering(true);\r\n      \r\n      try {\r\n        // Generate visual directives from scene description using LLM\r\n        const visualDirectives = await generateVisualDirectives(sceneDescription, mood);\r\n        \r\n        // Render background based on directives\r\n        renderer.drawBackgroundScene(sceneDescription, {\r\n          palette: visualDirectives.palette,\r\n          complexity: visualDirectives.complexity,\r\n          mood: mood\r\n        });\r\n        \r\n        // Render characters\r\n        characters.forEach(character => {\r\n          renderer.drawSilhouette(\r\n            character.description,\r\n            character.position,\r\n            {\r\n              size: character.size || 100,\r\n              opacity: character.opacity || 0.8,\r\n              color: character.color || '#000000'\r\n            }\r\n          );\r\n        });\r\n        \r\n        // Apply any special effects\r\n        if (visualDirectives.effects && visualDirectives.effects.length > 0) {\r\n          for (const effect of visualDirectives.effects) {\r\n            await renderer.drawEffect(effect.description, {\r\n              intensity: effect.intensity || 0.5,\r\n              duration: effect.duration || 2000,\r\n              color: effect.color || '#ffffff'\r\n            });\r\n          }\r\n        }\r\n        \r\n        onRenderComplete();\r\n      } catch (error) {\r\n        console.error('Error rendering scene:', error);\r\n      } finally {\r\n        setIsRendering(false);\r\n      }\r\n    };\r\n    \r\n    renderScene();\r\n  }, [sceneDescription, characters, mood, dimensions, renderer, onRenderComplete]);\r\n  \r\n  return (\r\n    <CanvasContainer className={className} isRendering={isRendering}>\r\n      <canvas ref={canvasRef} />\r\n      {isRendering && <LoadingIndicator />}\r\n    </CanvasContainer>\r\n  );\r\n};\r\n\r\n// Generate visual directives from scene description using LLM\r\nconst generateVisualDirectives = async (sceneDescription, mood) => {\r\n  try {\r\n    // Default values in case LLM fails\r\n    const defaultDirectives = {\r\n      palette: ['#1a1a2e', '#16213e', '#0f3460', '#e94560'],\r\n      complexity: 0.5,\r\n      effects: []\r\n    };\r\n    \r\n    // Skip LLM call if description is too short\r\n    if (!sceneDescription || sceneDescription.length < 10) {\r\n      return defaultDirectives;\r\n    }\r\n    \r\n    // Prompt for the LLM to generate visual directives\r\n    const prompt = `\r\n      Based on the following scene description, generate visual directives for rendering the scene.\r\n      The mood of the scene is: ${mood}.\r\n      \r\n      Scene description: \"${sceneDescription}\"\r\n      \r\n      Respond with a JSON object containing:\r\n      1. A color palette (array of 4 hex colors: sky, ground, middle, accent)\r\n      2. Complexity value (0.0 to 1.0)\r\n      3. Optional array of visual effects (each with description, intensity, duration, color)\r\n      \r\n      Example format:\r\n      {\r\n        \"palette\": [\"#1a1a2e\", \"#16213e\", \"#0f3460\", \"#e94560\"],\r\n        \"complexity\": 0.7,\r\n        \"effects\": [\r\n          {\r\n            \"description\": \"flash\",\r\n            \"intensity\": 0.5,\r\n            \"duration\": 2000,\r\n            \"color\": \"#ffffff\"\r\n          }\r\n        ]\r\n      }\r\n    `;\r\n    \r\n    // Call LLM service\r\n    const response = await llmService.generateStoryContent(prompt, {\r\n      temperature: 0.3, // Lower temperature for more consistent results\r\n      maxTokens: 256    // Small response size\r\n    });\r\n    \r\n    // Parse JSON response\r\n    try {\r\n      // Find JSON object in response\r\n      const jsonMatch = response.match(/\\{[\\s\\S]*}/);\r\n      if (jsonMatch) {\r\n        const directives = JSON.parse(jsonMatch[0]);\r\n        \r\n        // Validate palette\r\n        if (!directives.palette || !Array.isArray(directives.palette) || directives.palette.length < 4) {\r\n          directives.palette = defaultDirectives.palette;\r\n        }\r\n        \r\n        // Validate complexity\r\n        if (typeof directives.complexity !== 'number' || directives.complexity < 0 || directives.complexity > 1) {\r\n          directives.complexity = defaultDirectives.complexity;\r\n        }\r\n        \r\n        // Validate effects\r\n        if (!directives.effects || !Array.isArray(directives.effects)) {\r\n          directives.effects = [];\r\n        }\r\n        \r\n        return directives;\r\n      }\r\n    } catch (parseError) {\r\n      console.error('Error parsing LLM response:', parseError);\r\n    }\r\n    \r\n    // Return default directives if parsing fails\r\n    return defaultDirectives;\r\n  } catch (error) {\r\n    console.error('Error generating visual directives:', error);\r\n    return {\r\n      palette: ['#1a1a2e', '#16213e', '#0f3460', '#e94560'],\r\n      complexity: 0.5,\r\n      effects: []\r\n    };\r\n  }\r\n};\r\n\r\n// Styled components\r\nconst CanvasContainer = styled.div`\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  z-index: 0;\r\n  \r\n  canvas {\r\n    width: 100%;\r\n    height: 100%;\r\n    display: block;\r\n  }\r\n  \r\n  opacity: ${props => props.isRendering ? 0.7 : 1};\r\n  transition: opacity 0.5s ease;\r\n`;\r\n\r\nconst LoadingIndicator = styled.div`\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  transform: translate(-50%, -50%);\r\n  width: 50px;\r\n  height: 50px;\r\n  border: 5px solid rgba(255, 255, 255, 0.3);\r\n  border-radius: 50%;\r\n  border-top-color: #ffffff;\r\n  animation: spin 1s ease-in-out infinite;\r\n  \r\n  @keyframes spin {\r\n    to { transform: translate(-50%, -50%) rotate(360deg); }\r\n  }\r\n`;\r\n\r\nexport default SceneRenderer;","import React, { useEffect, useRef } from 'react';\r\n\r\n/**\r\n * CharacterSilhouette component\r\n * Renders character silhouettes to maximize player imagination\r\n */\r\nconst CharacterSilhouette = ({ \r\n  character, \r\n  position = 'center', \r\n  emotion = 'neutral',\r\n  speaking = false,\r\n  entering = false,\r\n  exiting = false,\r\n  size = 'medium'\r\n}) => {\r\n  const silhouetteRef = useRef(null);\r\n\r\n  // Apply animations based on props\r\n  useEffect(() => {\r\n    if (!silhouetteRef.current) return;\r\n    \r\n    const element = silhouetteRef.current;\r\n    \r\n    // Reset classes\r\n    element.className = 'character-silhouette';\r\n    \r\n    // Add position class\r\n    element.classList.add(`position-${position}`);\r\n    \r\n    // Add emotion class\r\n    element.classList.add(`emotion-${emotion}`);\r\n    \r\n    // Add size class\r\n    element.classList.add(`size-${size}`);\r\n    \r\n    // Add animation classes\r\n    if (speaking) element.classList.add('speaking');\r\n    if (entering) element.classList.add('entering');\r\n    if (exiting) element.classList.add('exiting');\r\n    \r\n  }, [position, emotion, speaking, entering, exiting, size]);\r\n\r\n  // Get silhouette shape based on character type and emotion\r\n  const getSilhouetteShape = () => {\r\n    // Default silhouette is a basic human shape\r\n    if (!character || !character.type) {\r\n      return (\r\n        <svg viewBox=\"0 0 100 200\" className=\"silhouette-svg\">\r\n          <path d=\"M50,10 C65,10 75,25 75,40 C75,55 65,70 50,70 C35,70 25,55 25,40 C25,25 35,10 50,10 Z\" />\r\n          <path d=\"M30,75 C40,73 60,73 70,75 C75,75 80,80 80,85 L80,180 C80,190 75,195 70,195 L30,195 C25,195 20,190 20,180 L20,85 C20,80 25,75 30,75 Z\" />\r\n        </svg>\r\n      );\r\n    }\r\n\r\n    // Return specific silhouette based on character type\r\n    switch (character.type) {\r\n      case 'adult-male':\r\n        return (\r\n          <svg viewBox=\"0 0 100 200\" className=\"silhouette-svg\">\r\n            <path d=\"M50,10 C67,10 80,23 80,40 C80,57 67,70 50,70 C33,70 20,57 20,40 C20,23 33,10 50,10 Z\" />\r\n            <path d=\"M30,75 C40,73 60,73 70,75 C75,75 85,80 85,85 L85,180 C85,190 80,195 75,195 L25,195 C20,195 15,190 15,180 L15,85 C15,80 25,75 30,75 Z\" />\r\n          </svg>\r\n        );\r\n      \r\n      case 'adult-female':\r\n        return (\r\n          <svg viewBox=\"0 0 100 200\" className=\"silhouette-svg\">\r\n            <path d=\"M50,10 C65,10 75,25 75,40 C75,55 65,70 50,70 C35,70 25,55 25,40 C25,25 35,10 50,10 Z\" />\r\n            <path d=\"M30,75 C40,73 60,73 70,75 C80,80 85,100 90,130 C92,150 85,180 80,195 L20,195 C15,180 8,150 10,130 C15,100 20,80 30,75 Z\" />\r\n          </svg>\r\n        );\r\n      \r\n      case 'child':\r\n        return (\r\n          <svg viewBox=\"0 0 100 200\" className=\"silhouette-svg\">\r\n            <path d=\"M50,20 C62,20 70,32 70,45 C70,58 62,70 50,70 C38,70 30,58 30,45 C30,32 38,20 50,20 Z\" />\r\n            <path d=\"M35,75 C42,73 58,73 65,75 C70,75 75,80 75,85 L75,180 C75,190 70,195 65,195 L35,195 C30,195 25,190 25,180 L25,85 C25,80 30,75 35,75 Z\" />\r\n          </svg>\r\n        );\r\n        \r\n      case 'elderly':\r\n        return (\r\n          <svg viewBox=\"0 0 100 200\" className=\"silhouette-svg\">\r\n            <path d=\"M50,10 C65,10 75,25 75,40 C75,55 65,70 50,70 C35,70 25,55 25,40 C25,25 35,10 50,10 Z\" />\r\n            <path d=\"M40,75 C45,73 55,73 60,75 C65,75 70,80 70,85 C75,110 75,140 70,170 L70,180 C70,190 65,195 60,195 L40,195 C35,195 30,190 30,180 L30,170 C25,140 25,110 30,85 C30,80 35,75 40,75 Z\" />\r\n          </svg>\r\n        );\r\n        \r\n      default:\r\n        return (\r\n          <svg viewBox=\"0 0 100 200\" className=\"silhouette-svg\">\r\n            <path d=\"M50,10 C65,10 75,25 75,40 C75,55 65,70 50,70 C35,70 25,55 25,40 C25,25 35,10 50,10 Z\" />\r\n            <path d=\"M30,75 C40,73 60,73 70,75 C75,75 80,80 80,85 L80,180 C80,190 75,195 70,195 L30,195 C25,195 20,190 20,180 L20,85 C20,80 25,75 30,75 Z\" />\r\n          </svg>\r\n        );\r\n    }\r\n  };\r\n\r\n  // If no character, don't render anything\r\n  if (!character) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <div \r\n      ref={silhouetteRef}\r\n      className={`character-silhouette position-${position} emotion-${emotion} size-${size} ${speaking ? 'speaking' : ''} ${entering ? 'entering' : ''} ${exiting ? 'exiting' : ''}`}\r\n      data-character-id={character.id}\r\n      data-character-name={character.name}\r\n      role=\"img\"\r\n      aria-label={`${character.name || '캐릭터'} ${speaking ? '말하는 중' : ''} ${emotion !== 'neutral' ? emotion : ''}`}\r\n    >\r\n      {getSilhouetteShape()}\r\n      \r\n      {/* Optional character name display */}\r\n      {character.showName && (\r\n        <div \r\n          className=\"character-name\"\r\n          aria-hidden=\"true\" // Name is already included in the aria-label\r\n        >\r\n          {character.name}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CharacterSilhouette;","import React, { useState, useEffect } from 'react';\r\nimport styled from 'styled-components';\r\nimport { useGame } from '../../contexts/GameContext';\r\nimport GameContainer from './GameContainer';\r\nimport TextDisplay from './TextDisplay';\r\nimport ChoiceSelection from './ChoiceSelection';\r\nimport SceneRenderer from './SceneRenderer';\r\nimport CharacterSilhouette from '../ui/CharacterSilhouette';\r\nimport soundEffects from '../../services/audio/soundEffects';\r\n\r\n// Main game screen component\r\nconst GameScreen = () => {\r\n  const game = useGame();\r\n  const [textDisplayComplete, setTextDisplayComplete] = useState(false);\r\n  // We're removing the sceneRenderComplete state since it's not used in the component\r\n  const [typingSound, setTypingSound] = useState(null);\r\n  \r\n  // Handle text display completion\r\n  const handleTextDisplayComplete = () => {\r\n    setTextDisplayComplete(true);\r\n    \r\n    // Stop typing sound if playing\r\n    if (typingSound) {\r\n      soundEffects.stopSfx('UI_TEXT_TYPING');\r\n      setTypingSound(null);\r\n    }\r\n    \r\n    // Play choice appear sound if there are choices\r\n    if (game.currentScene?.choices?.length > 0) {\r\n      soundEffects.playSfx('UI_CHOICE_APPEAR');\r\n    }\r\n  };\r\n  \r\n  // Handle scene render completion\r\n  const handleSceneRenderComplete = () => {\r\n    // We removed the sceneRenderComplete state since it wasn't used elsewhere\r\n    // This function is still needed for the SceneRenderer onRenderComplete prop\r\n  };\r\n  \r\n  // Handle choice selection\r\n  const handleChoiceSelect = (choice, index) => {\r\n    setTextDisplayComplete(false);\r\n    game.selectChoice(index);\r\n  };\r\n  \r\n  // Reset state when scene changes\r\n  useEffect(() => {\r\n    setTextDisplayComplete(false);\r\n    \r\n    // Play typing sound\r\n    if (game.currentScene) {\r\n      const sound = soundEffects.playSfx('UI_TEXT_TYPING', { loop: true });\r\n      setTypingSound(sound);\r\n    }\r\n    \r\n    // Clean up\r\n    return () => {\r\n      if (typingSound) {\r\n        soundEffects.stopSfx('UI_TEXT_TYPING');\r\n      }\r\n    };\r\n  }, [game.currentScene, typingSound]);\r\n  \r\n  // If no current scene, show loading\r\n  if (!game.currentScene) {\r\n    return (\r\n      <GameContainer>\r\n        <LoadingContainer>\r\n          <LoadingSpinner />\r\n          <LoadingText>Loading story...</LoadingText>\r\n        </LoadingContainer>\r\n      </GameContainer>\r\n    );\r\n  }\r\n  \r\n  return (\r\n    <GameContainer>\r\n      {/* Scene renderer for background */}\r\n      <SceneRenderer \r\n        sceneDescription={game.currentScene.content}\r\n        characters={game.characters}\r\n        mood={game.currentScene.mood}\r\n        onRenderComplete={handleSceneRenderComplete}\r\n      />\r\n      \r\n      {/* Character silhouettes */}\r\n      {game.characters.map(character => (\r\n        <CharacterSilhouette\r\n          key={character.id}\r\n          position={character.position}\r\n          emotion={character.emotion || 'neutral'}\r\n          size={character.size || 'medium'}\r\n          opacity={character.opacity || 0.8}\r\n        />\r\n      ))}\r\n      \r\n      {/* Game UI */}\r\n      <GameUI>\r\n        {/* Text display */}\r\n        <TextDisplay\r\n          text={game.currentScene.content}\r\n          typingSpeed={game.settings.textSpeed}\r\n          onComplete={handleTextDisplayComplete}\r\n          instantDisplay={game.isLoading}\r\n        />\r\n        \r\n        {/* Choice selection */}\r\n        <ChoiceSelection\r\n          choices={game.currentScene.choices}\r\n          onSelect={handleChoiceSelect}\r\n          visible={textDisplayComplete && !game.isLoading}\r\n        />\r\n      </GameUI>\r\n      \r\n      {/* Loading overlay */}\r\n      {game.isLoading && (\r\n        <LoadingOverlay>\r\n          <LoadingSpinner />\r\n        </LoadingOverlay>\r\n      )}\r\n      \r\n      {/* Game controls */}\r\n      <GameControls>\r\n        <ControlButton onClick={() => game.setCurrentScreen('settings')}>\r\n          Settings\r\n        </ControlButton>\r\n        <ControlButton onClick={() => game.setCurrentScreen('title')}>\r\n          Main Menu\r\n        </ControlButton>\r\n      </GameControls>\r\n    </GameContainer>\r\n  );\r\n};\r\n\r\n// Styled components\r\nconst GameUI = styled.div`\r\n  position: absolute;\r\n  bottom: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  padding: 1rem;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  z-index: 10;\r\n`;\r\n\r\nconst LoadingContainer = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  height: 100%;\r\n  color: #ffffff;\r\n`;\r\n\r\nconst LoadingText = styled.div`\r\n  margin-top: 1rem;\r\n  font-size: 1.2rem;\r\n  font-family: 'Noto Sans', sans-serif;\r\n`;\r\n\r\nconst LoadingSpinner = styled.div`\r\n  width: 50px;\r\n  height: 50px;\r\n  border: 5px solid rgba(255, 255, 255, 0.3);\r\n  border-radius: 50%;\r\n  border-top-color: #ffffff;\r\n  animation: spin 1s ease-in-out infinite;\r\n  \r\n  @keyframes spin {\r\n    to { transform: rotate(360deg); }\r\n  }\r\n`;\r\n\r\nconst LoadingOverlay = styled.div`\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  background-color: rgba(0, 0, 0, 0.7);\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  z-index: 100;\r\n`;\r\n\r\nconst GameControls = styled.div`\r\n  position: absolute;\r\n  top: 1rem;\r\n  right: 1rem;\r\n  display: flex;\r\n  gap: 0.5rem;\r\n  z-index: 20;\r\n`;\r\n\r\nconst ControlButton = styled.button`\r\n  background-color: rgba(0, 0, 0, 0.7);\r\n  color: #d0d0d0;\r\n  border: 1px solid rgba(255, 255, 255, 0.2);\r\n  border-radius: 4px;\r\n  padding: 0.5rem 1rem;\r\n  font-size: 0.9rem;\r\n  cursor: pointer;\r\n  transition: all 0.2s ease;\r\n  \r\n  &:hover {\r\n    background-color: rgba(40, 40, 40, 0.9);\r\n    color: #ffffff;\r\n    border-color: rgba(255, 255, 255, 0.5);\r\n  }\r\n`;\r\n\r\nexport default GameScreen;"],"names":["Container","styled","div","BackgroundLayer","props","backgroundImage","ContentLayer","_ref","children","containerRef","useRef","useEffect","updateDimensions","window","addEventListener","removeEventListener","_jsxs","ref","_jsx","TextContainer","isComplete","Cursor","span","text","typingSpeed","onComplete","instantDisplay","className","displayedText","setDisplayedText","useState","setIsComplete","textRef","timerRef","charIndexRef","current","clearInterval","setInterval","length","prev","onClick","handleClick","ChoicesContainer","ChoiceButton","button","isHovered","animationComplete","animationDelay","choices","onSelect","visible","hoveredIndex","setHoveredIndex","setAnimationComplete","timer","setTimeout","clearTimeout","map","choice","index","handleSelect","onMouseEnter","onMouseLeave","disabled","canvasRenderer","constructor","this","canvas","ctx","width","height","renderQueue","animationFrameId","isRendering","initialize","getContext","console","log","clear","clearRect","startRendering","render","stopRendering","cancelAnimationFrame","shift","requestAnimationFrame","addToRenderQueue","renderItem","push","drawBackgroundScene","description","options","arguments","undefined","palette","complexity","mood","backgroundRender","isNight","toLowerCase","includes","isRaining","isFoggy","isForest","isIndoor","skyColor","groundColor","middleColor","darkenColor","lightenColor","blendColors","skyGradient","createLinearGradient","addColorStop","fillStyle","fillRect","groundGradient","treeCount","Math","floor","i","x","random","y","treeHeight","treeWidth","beginPath","arc","PI","fill","windowWidth","windowHeight","windowX","windowY","strokeStyle","lineWidth","rainX","rainY","rainLength","moveTo","lineTo","stroke","fogY","fogHeight","rect","detailCount","size","drawSilhouette","position","opacity","color","silhouetteRender","isTall","isShort","isSlender","isLarge","actualSize","parseInt","slice","headRadius","closePath","drawEffect","intensity","duration","effectRender","startTime","Date","now","elapsed","progress","min","indexOf","splice","isFlash","isFade","isShake","isReveal","alpha","sin","amplitude","offsetX","offsetY","save","translate","restore","revealProgress","radius","sqrt","clip","Promise","resolve","amount","r","g","b","newR","max","newG","newB","toString","padStart","color1","color2","ratio","r1","g1","b1","r2","g2","b2","generateVisualDirectives","async","sceneDescription","defaultDirectives","effects","prompt","response","llmService","temperature","maxTokens","jsonMatch","match","directives","JSON","parse","Array","isArray","parseError","error","CanvasContainer","LoadingIndicator","characters","onRenderComplete","canvasRef","dimensions","setDimensions","setIsRendering","renderer","useCanvasRenderer","clientWidth","clientHeight","parentElement","visualDirectives","forEach","character","effect","renderScene","emotion","speaking","entering","exiting","silhouetteRef","element","classList","add","id","name","role","getSilhouetteShape","type","viewBox","d","showName","GameUI","LoadingContainer","LoadingText","LoadingSpinner","LoadingOverlay","GameControls","ControlButton","GameScreen","game","useGame","textDisplayComplete","setTextDisplayComplete","typingSound","setTypingSound","currentScene","sound","soundEffects","loop","GameContainer","SceneRenderer","content","handleSceneRenderComplete","CharacterSilhouette","TextDisplay","settings","textSpeed","handleTextDisplayComplete","_game$currentScene","_game$currentScene$ch","isLoading","ChoiceSelection","handleChoiceSelect","selectChoice","setCurrentScreen"],"sourceRoot":""}